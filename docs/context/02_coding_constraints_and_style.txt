

---

### `docs/context/02_coding_constraints_and_style.md`

```markdown
# Coding Constraints and Style

This document covers language/version constraints and general coding style. Behavioural prohibitions and requirements are extended in `05_coding_rules_requirements_and_prohibitions.md`.

## Language and Compiler Targets

Kernel modules (`source/system`, `source/core`, `source/world`, `source/schedule`, `source/save`, `source/config`, `source/engine`, `source/mods`, `source/runtime`, `source/utility`):

- Use C++98 subset.
- Must compile on:
  - Modern compilers (GCC/Clang/MSVC).
  - Older compilers suitable for DOS/Win16/Win32 where feasible.

Platform modules and tools/tests:

- May use a slightly more modern C++ (but avoid advanced features if not needed).
- May use limited STL containers and utilities where they do not leak into kernel interfaces.

## Allowed Features (Kernel)

- POD structs and simple classes.
- Namespaces.
- Plain `enum` types.
- Simple templates in `source/utility` and non-hot paths.
- Inline functions for small utilities.

## Forbidden Features (Kernel)

- Exceptions:
  - No `throw`, `try`, or `catch`.
- RTTI:
  - No `dynamic_cast` or `typeid`.
- Heavy STL in hot paths:
  - Minimise use of `std::vector`, `std::map`, etc.
  - No unordered containers that introduce non-deterministic iteration order.
- Platform-specific headers in kernel modules:
  - No `<windows.h>`, `<pthread.h>`, `<emscripten.h>`, etc. in core/world/schedule/save/system/config/utility.

## Determinism-Related Style

- No floating-point arithmetic in any path that mutates simulation state or affects decisions.
- All random behaviour must go through `source/system/rng.*`.
- Functions that mutate state must have explicit, narrow responsibilities.
- No hidden reads/writes through global state in kernel code, except where strictly justified and documented (e.g. global config or profiles).

## Header and Include Discipline

- Each header must have a unique include guard.
- Minimise dependencies:
  - Prefer forward declarations in headers where possible.
  - Include implementation details in `.cpp` files instead of `.h`.
- Avoid cyclic dependencies:
  - Use opaque handles/IDs and forward declarations to break cycles.

## Naming Conventions

- File names:
  - Lowercase with underscores where necessary (`core_api.h`, `world_space.h`, `state_hash.cpp`).
- Types:
  - `CamelCase` for types (`CoreState`, `WorldGrid`).
- Functions:
  - `snake_case` for functions (`core_init`, `compute_state_hash`).
- Constants:
  - `UPPER_SNAKE_CASE` for compile-time constants, especially in config or system_base.

## Error Handling

- Kernel:
  - Return status codes, error enums, or use dedicated error-reporting APIs in `source/runtime/rt_error.*`.
  - No exceptions.
- Platform/tools:
  - May use exceptions if strictly contained and not visible at kernel boundaries (prefer not to).

## Testing Expectations

- New kernel features:
  - Require at least basic tests under `tests/`:
    - Correctness tests.
    - If they influence determinism, add replay/hash tests.
- Use test naming that reflects module and feature.

This style and constraint set is mandatory for any code generation or refactoring in this project.
